<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReveilLib: Reckless Controller Usage Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ReveilLib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2tutorials_2reckless.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Reckless Controller Usage Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md3"></a></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Getting Started</h1>
<p>Before you can use the reckless controller, you need to get a few things out of the way</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Includes</h2>
<p>In order to use Reckless, you need ReveilLib. You can do this by including <a class="el" href="rev_8hh_source.html">rev.hh</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rev/rev.hh&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Chassis</h2>
<p>The Reckless controller is designed for use with a skid-steer chassis, so that is what this guide will focus on. The skid-steer chassis relies on PROS motor groups. Below is an example configuration with 2 motor groups, one for the left side of the chassis and one for the right side, as used with Slingo, the WHOOP Spin Up 15 inch robot.</p>
<div class="fragment"><div class="line">pros::Motor_Group leftd({15, 18, -19, -20});</div>
<div class="line">pros::Motor_Group rightd({4, 6, -7, -9});</div>
</div><!-- fragment --><p>With the motor groups defined, you can build your chassis model</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;rev::SkidSteerChassis&gt; chassis =</div>
<div class="line">    std::make_shared&lt;rev::SkidSteerChassis&gt;(leftd, rightd);</div>
</div><!-- fragment --><p>If you don't want to use a skid steer chassis, you can also define your own compatible chassis model by implementing the <code><a class="el" href="classrev_1_1Chassis.html" title="Interface for chassis objects.">rev::Chassis</a></code> interface. As of 1.0.0, ReveilLib does not support any models other than skid steer.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Odometry</h2>
<p>In addition to a chassis, an odometry system is also required. Like with chassis, a compatible custom odometry solution can be created by extending <code><a class="el" href="classrev_1_1Odometry.html" title="Interface for odometry implementations.">rev::Odometry</a></code>, however by default ReveilLib 1.0.0 only comes with a single odometry system type.</p>
<p>The TwoEncoderGyroOdometry system uses 3 sensors; an inertial and 2 rotation sensors. These can be set up as below:</p>
<div class="fragment"><div class="line">pros::Rotation fwd(5);        <span class="comment">// Rotation sensor connected to the wheel measuring forward translation</span></div>
<div class="line">pros::Rotation rgt(16, <span class="keyword">true</span>); <span class="comment">// Rotation sensor connected to the wheel measuring rightward translation. </span></div>
<div class="line">                              <span class="comment">// This one had to be reversed because of the way the sensor was mounted.</span></div>
<div class="line">                              <span class="comment">// NOTE: Unlike motors, the PROS kernel requires you to use (port, true) syntax to initialize a reversed rotation sensor. If instead you try using (-port), it will not work.</span></div>
<div class="line">pros::Imu imu(14); <span class="comment">// Inertial sensor</span></div>
</div><!-- fragment --><p>Using this, you can then build an odometry system!</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;rev::TwoRotationInertialOdometry&gt; odom =</div>
<div class="line">  std::make_shared&lt;rev::TwoRotationInertialOdometry&gt;(</div>
<div class="line">    fwd,      <span class="comment">// The forward sensor</span></div>
<div class="line">    rgt,      <span class="comment">// The rightward sensor </span></div>
<div class="line">    imu,      <span class="comment">// Inertial sensor</span></div>
<div class="line">    2.09_in,  <span class="comment">// Diameter of forward wheel</span></div>
<div class="line">    2.75_in,  <span class="comment">// Diameter of sideways wheel</span></div>
<div class="line">    4.75_in,  <span class="comment">// How far to the right of the center of the robot the forward wheel is</span></div>
<div class="line">    0.5_in    <span class="comment">// How far to the rear of the robot the lateral wheel is from the center</span></div>
<div class="line">  );</div>
</div><!-- fragment --><p>Additionally, you will need to initalize the odometry, as it has an associated thread. This can be done at the top of your autonomous function as follows </p><div class="fragment"><div class="line"><a class="code hl_class" href="classrev_1_1AsyncRunner.html">rev::AsyncRunner</a> odom_runner(odom);</div>
<div class="ttc" id="aclassrev_1_1AsyncRunner_html"><div class="ttname"><a href="classrev_1_1AsyncRunner.html">rev::AsyncRunner</a></div><div class="ttdoc">Thread runner for AsyncRunnable.</div><div class="ttdef"><b>Definition</b> async_runner.hh:18</div></div>
</div><!-- fragment --><p>The inertial sensor automatically calibrates every time a Vex program starts, so it might be wise to wait a few seconds before creating the runner.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Reckless controller</h2>
<p>Finally you can build the Reckless controller itsself.</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;rev::Reckless&gt; reckless =</div>
<div class="line">      std::make_shared&lt;Reckless&gt;(chassis, odom);</div>
</div><!-- fragment --><p>and to make it run, just add this to the top of your autonomous function</p>
<div class="fragment"><div class="line">AsyncRunner reckless_runner(reckless);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Using the Reckless controller</h1>
<p>The Reckless controller accepts a series of path segments for it to follow. An example path is shown below</p>
<div class="fragment"><div class="line">reckless-&gt;go(</div>
<div class="line">  RecklessPath()</div>
<div class="line">    .with_segment(RecklessPathSegment(</div>
<div class="line">        std::make_shared&lt;CascadingMotion&gt;(0.7, kP, kB,</div>
<div class="line">                                          60_in / second, 0.07),</div>
<div class="line">        std::make_shared&lt;PilonsCorrection&gt;(2, 0.5_in),</div>
<div class="line">        std::make_shared&lt;SimpleStop&gt;(0_s, 0.3_s, 0.2),</div>
<div class="line">        {-2_ft, 0_ft, 0_deg}, 0_in))</div>
<div class="line">    .with_segment(RecklessPathSegment(</div>
<div class="line">        std::make_shared&lt;CascadingMotion&gt;(0.7, kP, kB,</div>
<div class="line">                                          60_in / second, 0.07),</div>
<div class="line">        std::make_shared&lt;PilonsCorrection&gt;(2, 0.5_in),</div>
<div class="line">        std::make_shared&lt;SimpleStop&gt;(.1_s, 0.2_s, 0.4),</div>
<div class="line">        {-4_ft, -1_ft, 45_deg}, 0_in))</div>
<div class="line">    .with_segment(RecklessPathSegment(</div>
<div class="line">        std::make_shared&lt;CascadingMotion&gt;(0.7, kP, kB,</div>
<div class="line">                                          60_in / second, 0.07),</div>
<div class="line">        std::make_shared&lt;PilonsCorrection&gt;(2, 0.5_in),</div>
<div class="line">        std::make_shared&lt;SimpleStop&gt;(0.075_s, 0.2_s, 0.4),</div>
<div class="line">        {0_ft, 0_ft, 0_deg}, 0_in)</div>
<div class="line">));</div>
</div><!-- fragment --><p>While the motion, correction, and stopping algorithms can be overridden for each segment of the path, ReveilLib comes with 3 motion algorithms, 2 correction algorithms, and 1 stop algorithm built in</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Motion</h2>
<p>ReveilLib's 3 motion algorithms are <code>Constant</code>, <code>Proportional</code>, and <code>Cascading</code>.</p>
<p><code>ConstantMotion</code> is the simplest of the 3, and just outputs a constant power. It can be created with</p>
<div class="fragment"><div class="line">std::make_shared&lt;ConstantMotion&gt;(power)</div>
</div><!-- fragment --><p>where you can replace <code>power</code> with whatever power you wish to use, from 0 to 1</p>
<p>The next motion algorithm is <code>ProportionalMotion</code>. This one is slightly more complicated, and has 2 parameters; a proportional gain and a max power. It can be made as follows:</p>
<div class="fragment"><div class="line">std::make_shared&lt;ProportionalMotion&gt;(max_power, k_p)</div>
</div><!-- fragment --><p>where <code>max_power</code> is the max power and <code>k_p</code> is the proportional gain.</p>
<p>Finally, <code>CascadingMotion</code> is the most complicated, with 5 parameters. This one attempts to move at a consistent speed, unlike ProportionalMotion, which only cares about voltage output.</p>
<div class="fragment"><div class="line">std::make_shared&lt;CascadingMotion&gt;(max_power, k_p, k_b, max_speed, k_v)</div>
</div><!-- fragment --><p><code>max_power</code> is the maximum power the controller will output, from 0 to 1.</p>
<p><code>k_p</code> is a constant of proportionality aiming to increase the robot's speed if it is below its target speed or slow it down if it's going too fast.</p>
<p><code>k_b</code> is a feed-forward proportional gain aiming to make the robot move at a specific speed.</p>
<p><code>max_v</code> is a speed limit for the robot to target.</p>
<p><code>k_v</code> is a constant that determines how the robot will choose its target speed. <code>0.07</code> seems to work well.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Correction</h2>
<p>2 correction algorithms are provided</p>
<p><code>NoCorrection</code> is self-explainatory. It doesn't do anything.</p>
<p><code>PilonsCorrection</code> is an algorithm based on 5225A's In The Zone code. It can be made as following:</p>
<div class="fragment"><div class="line">std::make_shared&lt;PilonsCorrection&gt;(k_correction, max_error);</div>
</div><!-- fragment --><p><code>k_correction</code> is the proportional gain for correction. <code>2</code> seems to work well.</p>
<p><code>max_error</code> is a length expressing how far off the robot can be before it starts attempting to correct. <code>0.5_in</code> works well in testing.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Stopping</h2>
<p>We also need a stop controller. A simple one is provided.</p>
<div class="fragment"><div class="line">std::make_shared&lt;SimpleStop&gt;(k_h, k_c, pow_coast)</div>
</div><!-- fragment --><p><code>k_h</code> is a time such that if the robot continues at its current velocity and it will reach the target before that much more time passes, it will apply its harsh brakes.</p>
<p><code>k_c</code> is similar, but it will coast instead.</p>
<p><code>pow_coast</code> is the amount of power thats fed to the motors while coasting. This should be just enough to allow the robot to overcome friction and rolling resistance.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Target point</h2>
<p>The target point is the fifth parameter of a segment. Only the <code>x</code> and <code>y</code> matter however, as the robot really doesn't care where its facing (this can be corrected later using <code>CampbellTurn</code> though).</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Early Drop</h2>
<p>The early drop parameter allows you to make the robot begin execution of the next segment before it reaches the target point of the current one. This is particularly useful for making motions smoother. It just accepts a <code>QLength</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
